<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="https://w3c.github.io/scholarly-html/css/scholarly.min.css">
    <script src="https://w3c.github.io/scholarly-html/js/scholarly.min.js"></script>
</head>

<body prefix="schema: http://schema.org" style="font-family: calibri !important;">
    <header>
        <h1>Real Quest</h1>
    </header>

    <div role="contentinfo">
        <!-- <ol role="directory">
            <li><a href="#abstract"><span>1. </span>Abstractiune</a></li>
            <li><a href="#introduction"><span>2. </span>Introducere</a></li>
            <li><a href="#motivation"><span>3. </span>Motivatie</a>
            <li><a href="#structure"><span>4. </span>Structura proiectului</a>
                <ol role="directory">
                    <li><a href="#client"><span>4.1 </span>Client</a></li>
                    <ol role="directory">
                        <li><a href="#html"><span>4.1.1 </span>Paginile clientului</a></li>
                        <li><a href="#game-canvas"><span>4.1.2 </span>Canvasul jocului</a></li>
                        <li><a href="#client-side-services"><span>4.1.3 </span>Serviciile pe partea de client</a></li>
                    </ol>
                    <li><a href="#server"><span>4.2 </span>Server</a></li>
                    <ol role="directory">
                        <li><a href="#mvc"><span>4.2.1 </span>Structura serverului</a></li>
                        <li><a href="#server-apis"><span>4.2.2 </span>Serviciile puse la dispozitie de catre server</a></li>
                        <li><a href="#server-side-services"><span>4.2.3 </span>Serviciile folosite de catre server</a></li>
                    </ol>
                    <li><a href="#game"><span>4.3 </span>Mecanica jocului</a></li>
                    <ol role="directory">
                        <li><a href="#mapbox"><span>4.3.1 </span>Harta jocului</a></li>
                        <li><a href="#player-actions"><span>4.3.2 </span>Generarea de evenimente de catre jucator</a></li>
                        <li><a href="#game-community"><span>4.3.3 </span>Interactiunea jucatorului cu mediul inconjurator</a></li>
                    </ol>
                </ol>
            </li>
            <li><a href="#techs"><span>5. </span>Tehnologii utilizate</a></li>
            <li><a href="#biblio-references"><span>6. </span>Referinte</a></li>
        </ol> -->
        <dl>
            <dt>Autori</dt>
            <dd>
                <a href="https://github.com/blox-dev">Crainiciuc Călin Ștefan</a>
                &amp;
                <a href="https://github.com/firststef">Petrovici Ștefan</a>
                &amp;
                <a href="https://github.com/ancestor-mithril">Stoica George</a>

            </dd>
            <dt>Erori și recomandări</dt>
            <dd>
                <a href="https://github.com/firststef/twproj/issues">Issues and PRs welcome!</a>
            </dd>

            <dt>Licență</dt>
            <dd>
                <a href="">!! nu stiu daca trebuie pus ceva aici???</a>
            </dd>
        </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
        <h2>Abstracțiune</h2>
        <p>
            <q>Real Quest</q> este o aplicație care permite utilizatorilor să se materializeze într-un tărâm mistic,
            copie de rang secund a lumii reale, pentru a explora
            și vâna monștrii care vor să elimine orice formă de viață.
        </p>
    </section>
    <section id="introduction" role="doc-introduction">
        <h2>Introducere</h2>
        <p>
            Jocul <q>Real Quest</q> apelează la servicii web pentru a prelua informații despre locația utilizatorului și
            mediul în care se află, simulând mișcarea acestuia pe o hartă. Elementele spațiu-temporale reale sunt
            însoțite de monștrii virtuali, care vor ataca jucătorul.
        </p>

        <p>
            Clientul poate să explore împrejurimile, orientându-se dupa detalii precum numele de străzi și de clădiri,
            luptându-se cu monștrii pentru a câstiga puncte și a supraviețuii cât mai mult.
        </p>
    </section>
    <section id="motivation">
        <h2>Motivație</h2>
        <p>
            Acest proiect reprezinta tema noastra pentru proiectul de curs de Tehnologii Web al Facultatii de
            Informatica al Universitatii Alexandru Ioan Cuza.
        </p>
    </section>
    <section id="problem">
        <h2>Cerință</h2>
        <p>
            Pe baza unui API REST ori GraphQL propriu, să se realizeze o aplicație web de tip joc "Monster hunter"
            utilizând hărți reale preluate de la un serviciu web de cartografiere (ex. Google maps sau
            openstreetmaps.org). În joc vor fi simulate condițiile de vreme exterioare (vreme și luminozitate),
            parametri preluați de asemenea de la servicii web specializate. Locația de start a jucătorului va fi
            preluată prin intermediul API-ului de geolocalizare pus la dispoziție în HTML5 și jucătorul va fi capabil să
            vadă alți jucători pe hartă comunicând în timp real cu serverul utilizând WebSockets.
        </p>
        <p>
            Scopul jocului este de a obține cât mai multe puncte din învingerea inamicilor, inamici ce apar pe harta
            preluată cum s-a menționat mai sus. Inamicii -- folosind o strategie (euristică) generată prin program --
            tind a se apropia de avatarul jucătorului și dacă acesta nu se ferește de proiectilele lor, viața sa va
            scădea progresiv ( în concordanță cu artileria din dotarea inamicilor) până când va ajunge la zero puncte de
            vitalitate -- în acest caz, jocul se va termina pentru acel jucător și punctajul său este considerat final.
            În același mod, inamicii pot fi învinși prin scăderea punctelor de vitalitate prin contactul cu
            proiectilele/armamentul jucătorului. La finalul jocului se va afișa un clasament global al jucătorilor și
            punctajele lor.
        </p>
        <p>
            Sistemul va furniza în timp real clasamentul global al primilor J jucători și punctajele lor (minimal, în
            format XML, CSV). De asemenea se va permite descărcarea într-un format specific traciectoriilor GPS (ex.
            format GPX) a traseului parcurs de jucator în lumea reală.
        </p>
    </section>
    <section id="game">
        <h2>Implementarea jocului</h2>

        <section id="preparation">
            <h3>Pregătire și considerente</h3>
            <p>Primul pas a fost documentarea legata de api-urile pe care le vom utiliza. Am utilizat 3 api-uri: pentru
                timp, vreme si geolocatie. Api-urile apartin domeniilor dev.virtualearth.net, openweathermap.org si
                mapbox.com. Vom detalia utilizarea lor cand ajungem la ele in implementare.</p>

            <p>Am început implementarea prin construirea mecanicilor de bază a jocului. Platforma noastră de dezvoltare
                fiind Web-ul, mai specific, formatul HTML5, am ales ca tehnologie prinicpală HTML5 Canvas. Pentru acest
                joc, aveam nevoie de:
                - o modalitate prin care sa desenam forme geometrice in zone diferite (ex. cladirile)
                - folosirea de imagini (sprite-uri pentru personaj, monstri)
                - capturarea comenzilor utilizatorului
                - animatii de sprite-uri (pentru miscarea jucatorului)
                - sa putem muta formele geometrice </p>
            <p>
                Primele 3 cerinte erau indeplinite nativ de Canvas, insa pentru urmatoarele doua lucrurile nu erau asa
                de simple de realizat.
            </p>
            <p>
                In primul rand animatiile trebuiau realizate prin impartirea foii de animatie (spritesheet) in mai multe
                cadre, si inlocuirea cadrului curent la un anumit interval, in functie de viteza animatiei.
                In al doilea rand, mutarea entitatilor desenate pe ecran necesita o arhitectura arborescenta, in care
                fiecare nod copil se orienta relativ la parintele sau. Un exemplu de ce este nevoie de aceasta: stim ca
                pentru a observa efectul de miscare a personajului trebuie sa observam o translatie a obiectelor din
                interiorul lumii pe masura ce jucatorul se misca, si de asemenea trebuie ca acesta sa ramana in mijlocul
                ecranului, pentru ca utilizatorul sa vada la fel de mult din harta pe masura ce o parcurge. Pentru a
                crea acest efect in interiorul lumii 2d create, observam ca vom avea nevoie de un nod parinte, care
                contine obiectele lumii, inclusiv personajul, si trebuie sa mutam personajul relativ la acest nod, in
                functie de input. Ceea ce nu este asa de evident este ca tot in acelasi timp trebuie sa mutam si lumea
                cu totul, pentru a urmari personajul si a-l mentine in mijloc (nu avem in canvas conceptul de camera
                virtuala, care poate sa inspecteze obiecte intr-o locatie oarecare, ci noi desenam pe un viewport, si
                deci trebuie sa mutam obiectele). Fara o arhitectura si o implementare care sa ne ofere suportul pentru
                relatiile de tip parinte-copil, lucrul acesta ar fi fost extrem de dificil.
            </p>
            <p>
                In urma realizarilor acestor doua cerinte din urma, ne-am dat seama ca o implementare elaborata a
                acestora ar dura foarte mult. Din acest motiv, am cautat o implementare open-source ca sa ne ajute. Asa
                am descoperit CreateJS, o librarie cu o licenta deschisa si care avea implementari esentiale pentru
                jocul nostru.
            </p>
        </section>
        <section id="createjs">
            <h3>Cum am folosit CreateJS</h3>
            <p>
                Libraria permitea sa instantiem forme geometrice si imagini animate (sprite-uri) prin construirea de
                obiecte. Principiul de baza este urmatorul. Nodul radacina trebuia instantiat ca un obiect de tip Stage,
                si pentru fiecare copil adaugat lui, nodul parinte il va orienta in functie de pozitia proprie si
                deplasament.
            </p>
            <p>
                Cum pentru proiect exista restrictia de a nu folosi decat librarii, am avut grija ca alegerea noastra sa
                nu fie framework, si am judecat ca aceasta indeplineste conditia luand in considerare urmatoarele:
                - functiile din createjs reprezinta wrappere peste functiile clasice de desenat pe canvas, pastrand
                signaturi similare cu cele din api-ul original
                - clasele din createjs pot fi instantiate de noi cand dorim, avand control complet asupra obiectelor din
                lume
                - createjs nu ruleaza independent de codul nostru, positia obiectelor pe canvas se actualizeaza doar
                cand apelam stage.update(), stage fiind un obiect instantiat de noi
            </p>
            <p>
                Createjs are un obiect folosit pentru optimizare pe browser, Ticker, si are un rol de timer - calculeaza
                in functie de framerate-ul
                pe care il dorim si apeluri la requestAnimationFrame, cand trebuie sa apelam bucla principala (functia
                de update) a jocului, care este definita de noi.
            </p>
            <p>
                Dupa ce am capturat input-ul de la utilizator prin handle-uri pe evenimente de input de la tastatura si
                am introdus o imagine pentru personaj, am reusit sa facem un personaj care se putea orienta in spatiu.
            </p>
        </section>
        <section id="">
            <h3>Realizarea hartii</h3>
            <p>Harta noastra preia coordonate pentru strazi, cladiri, si mase de apa si le creeaza ca obiecte pe harta.
                Ordinea in care desenam obiectele creeaza si efectul de stratificare, necesar pentru noi ca jucatorul sa
                se pozitioneze deasupra strazilor si nu sub. Modul in care luam coordonatele este descris in sectiunea
                de mai jos, despre Mapbox. Coordonatele pe care le primim sunt puse in vectori sau multivectori de
                coordonate. Un vector de coordonate reprezinta conturul unei strazi/cladiri/mase de apa. Coordonatele
                cladirilor sunt salvate in doua locuri: prima data ca si forma geometrica pe ecran, iar a doua oara
                intr-un vector ca sa ne dam seama cand o cladire a fost deja primita si desenata, si ca sa calculam
                coliziunile cu jucatorii.</p>
            <p>
                Dupa ce am adaugat cladirile, am adaugat un algoritm pentru coliziune, la inceput foloseam o librarie cu
                un algoritm bazat pe intersectie de poligoane, dar dupa, am renuntat la ea si am facut noi o
                implementare mai optima, calculand distante fata de muchiile cladirii. Am adaugat doua optimizari pentru
                coliziune, prima calculeaza limite pentru cladire si se asigura ca vom face operatia de calcul de
                coliziune (care este costisitoare) doar in interiorul acestei limite, iar a doua calcula pe un interval
                limitele cladirilor si elimina cladirile indepartate, aplicand coliziunea doar pe cele care erau in raza
                noastra de actiune.
            </p>
        </section>
        <section id="weather">
            <h3>Afisarea vremii</h3>
            <p>
                Apeland serviciile pentru timp si vreme, completand ca si parametru locatia curenta a jucatorului,
                distingem tipul vremii: insorit, innourat cu ploaie, ninsoare si tipul de luminozitate: luminos/
                intunecat. In cazul in care serviciul esueaza, avem o functie care calculeaza aproximativ ora pe glob si
                o intoarce.
            </p>
            <p>
                Pentru animatia de ninsoare si ploaie, a fost necesar sa folosim api-ul nativ pentru setari
                mai avansate: ploaia trebuia sa aiba o animatie, si de asemenea, pentru a optimiza sprite-ul (sa nu avem
                o imagine mare formata din imagini mici repetate), buffer-ul sprite-ului trebuia repetat pe tot ecranul.
                In plus, am explicat mai sus ca pentru a crea efectul de miscare, trebuie sa mutam personajul, dar si
                lumea, ca sa pastram in mijloc caracterul. Doar ca lumea trebuie mutata in sens invers miscarii
                personajului. Deci, trebuia sa deplasam originea imaginii cu distanta de de plasare a jucatorului.
                Clasele din CreateJS pot folosi functii trimise de noi in care apelam functiile de canvas native, acesta
                fiind modul de lucru pentru efectele complexe. Am realizat o astfel de functie, CreateJS-ul se asigura
                de schimbarea animatiei iar noi desenam pe tot ecranul animatia curenta si cu deplasamentul potrivit
                miscarii.
            </p>
        </section>
        <section id="loading">
            <h3>Incarcarea Resurselor</h3>
            <p>Pe langa api-urile care trebuie accesate la inceput, jocul trebuie sa incarce imaginile pentru jucator,
                monstri etc. Cum aceasta incarcare se realizeaza asincron, nu stim exact care dintre apelurile asincrone
                se va termina primul/ultimul/in ce ordine. Trebuia sa asteptam cateva secunde pentru ca acestea sa sa
                termine, si se vedea o pagina goala la inceput, pana incepea jocul, asa ca am pus o pagina de incarcare
                si am creat PageLoader, o clasa care inregistreaza functii asincrone si apeleaza un callback de
                terminare dupa ce toate functiile sunt terminate. In cazul nostru, noi doream sa afisam jocul cand se
                termina de incarcat, si am adaugat si pictograme care sa arate progresul, daca s-a incarcat sau nu
                resursa respectiva.</p>
            <p>Imaginile se incarca cu ajutorul unei clase din createjs, LoadQueue. Buffer-ul primit este folosit mai
                apoi la crearea din animatii prin impartirea ei in sectiuni, in functie de dimensiunea cadrelor si
                numarul lor.</p>
            <p>Cand PageLoader termina asteparea, jocul incepe.</p>
        </section>
        <section id="mechanics">
            <h3>Mecanicile de baza ale jocului. Interactiunea cu inamicii</h3>
            <p>Scopul jocului este obtinerea unui punctaj cat mai mare. Acesta depinde de cati monstri ai invins si cat
                de mult ai rezistat in joc. Jucatorul se deplaseaza cu ajutorul tastelor WASD si poate arunca proiectile
                prin alegerea directiei folosind mouse-ul. Jocul se termina cand viata caracterului ajunge la 0, adica
                cand toata bara rosie din stanga-sus a ecranului se goleste.</p>
            <p>
                In cazul detectarii de coliziune cu o cladire, jucatorului nu i se va permite deplasarea spre aceasta.
                Monstrii sunt de doua tipuri, primul tip poate lansa proiectile spre personaj, iar al doilea tip este
                mult mai rapid, insa nu are proiectile. Monstrii blocheaza trecerea,iar daca sunt in contact cu
                jucatorul, acesta pierde puncte de vitalitate.
            </p>
        </section>
        <section id="bonuses">
            <h3>Bonusuri</h3>
            <p>Pe harta apar din cand in cand anumite iconite care reprezinta un avantaj (uneori temporar) pentru
                jucator: sacul de bani reprezinta 50 de puncte in plus, papucul cu aripi ofera cateva secunde de viteza
                dubla, iar cheile mov pot "deschide" cladirile, adica jucatorul poate sa treaca prin ele. Cheile sunt
                stivuibile, dar papucii reseteaza intervalul de viteza la contact.</p>
        </section>
        <section id="art">
            <h3>Arta si design</h3>
            <p>Un joc este un proiect foarte laborios, pentru ca este format din foarte multe elemente: ideea jocului,
                cat de distractiva este aceasta, design-ul jocului, daca resursele dau un aspect estetic impreuna
                (consistenta), mecanica de baza a jocului, cat de echilibrate sunt castigurile fata de efortul depus de
                jucator, cat de accesibile sunt controalele etc. Am incercat sa avem in vedere toate aceste aspecte,
                realizand cat mai mult din fiecare.</p>
            <p>
                Resursele grafice au fost desenate de noi (Sprite-ul personajului si al monstrilor, animatiile, cele
                doua imagini cu eroul de pe pagina principala, sprite-urile pentru power-up-uri), dar pot fi folosite de
                cine doreste.
            </p>
            <p>De asemenea am scris si o introducere pe pagina principala, pentru a oferi un context jocului. </p>
        </section>
        <section id="formats">
            <h3>Formatele exportate</h3>
            <p>
                Pe parcursul jocului sunt salvate punctele geografice prin care trece jucatorul, iar la final el poate
                descarca un fisier GPX cu traseul parcurs. De asemenea pe pagina de final, utilizatorul poate descarca
                clasamentul jocului in format CSV.
            </p>
        </section>
        <section id="multiplayer">
            <h3>Multiplayer</h3>
            <p>
                Un lucru interesant la un joc retro este sa ai capabilitati multiplayer. Jucatorii isi pot observa unul
                celuilalt pozitia si pot interactiona prin intermediul chat-ului. Din pacate calculele nu se realizeaza
                la nivel de server, ci jocul e mai mult client-based, si sunt explicate mai jos motivele si incercarile
                noastre.
            </p>
        </section>
        <section id="mobile">
            <h3>Versiunea de mobil</h3>
            <p>
                Pentru versiunea de mobil am adaugat o implementare luata de pe un repo open-source pentru un joystick
                html5[1]. Pe ecranele mici, sunt 2 joystick-uri: cel din dreapta este pentru miscarea personajului, iar
                cel din stanga, daca nu este in starea default, trimite un proiectil in directia in care este indreptat.
            </p>
        </section>
        <section id="mapbox">
            <h3>Despre dependinta la Mapbox GL JS</h3>
            <p>
                Unul din api-urile pe care le-am folosit a fost cel de geolocatie. Acesta ne intorcea cele mai apropiate
                obiecte (strazi, cladiri, monumente, etc). Insa problema era ca nu ne intorcea coordonatele conturului
                acestora. Am cautat suplimentar fata de acesta alt serviciu si am realizat la dupa ce pornisem proiectul
                ca nu exista un api pentru delimitarile
                cladirilor/monumentelor/formelor de relief, care sa fie accesibil prin cerere http. Pana si google, care
                are o colectie foarte mare de harti si alte api-uri legate de acestea, nu avea un astfel de serviciu.
                Nici Openstreetmaps, nici alte domenii. Si pe noi ne-a intrigat acest aspect, dar exista intr-adevar un
                serviciu (Mapbox) care permitea descarcarea de fisiere compresate care contineau astfel de informatii.
                Insa in ciuda efortului depus, nu am reusit sa despachetam formatul respective (.pbf/.mvt), la inceput
                folosind gunzip, sau alte librarii, in javascript, in python. Formatul pe care Mapbox il punea la
                dispozitie pare ca se despacheta diferit fata de .pbf-urile normale, apartinand google. Un alt domeniu,
                openstreetmaps, mentiona ca are datele respective, dar printre implementarile oferite de ei, nu am gasit
                nicio implementare viabila. Cand spunem ca nu erau viabile, ne referim la mai multe probleme, in primul
                rand, noi doream initial ceva care sa fie sub forma de api, sau daca trebuia sa despachetam noi
                formatele, sa avem si o librarie care sa faca asta, dar unele implementari erau sdk-uri, librarii cu
                licenta non-open-source, sau scrise in c++ (si nu voiam server in c++).
            </p>
        </section>
    </section>
    <section id="structure">
        <h2>Structura proiectului</h2>
        <p>
            Fiind o aplicatie web, aceasta este structurată in interfața grafică prin care clientul are acces la joc,
            aplicația server care tratează cerințele clienților
            și un modul care se ocupă cu desfășurarea și logica jocului.
        </p>
        <section id="client">
            <h3>Client</h3>
            <p>
                Partea vizibilă utilizatorilor, clientul este reprezentat de pagini web create prin intermediul
                interacțiunii dintre HTML, CSS si JavaScript.
            </p>
            <section id="html">
                <h4>Paginile clientului</h4>
                <p>
                    Utilizatorul are acces la pagina de start, care conține o scurtă descriere și poveste a jocului,
                    precum si funcția de preluare a coordonatelor
                    utilizatorilor prin modulul API de geolocație al HTML5.
                </p>
                <p>
                    ??design html si css??
                </p>
                <p>
                    După apăsarea butonului de începere a jocului, se trimit către pagina de joc prin postare
                    coordonatele utilizatorului și numele acestuia.
                    Aplicația joc conține un canvas pe care este desenat un personaj care poate fi controlat de către
                    client, precum
                    și clădirile, străzile și apa din imediata apropiere a coordonatelor primite.
                </p>




            </section>
            <section id="game-canvas">
                <h4>Canvasul jocului</h4>
                <p>
                    Animația jocului este înglobată in canvasul de pe pagina de joc. Harta jocului este primită sub
                    forma de colecție de poligoane sau multipoligoane
                    care sunt alcătuite din colectii de puncte, iar clădirile, drumurile si apa sunt figuri desenate
                    prin unirea punctelor si umplerea poligoanelor.
                </p>
                <p>
                    Aceste figuri sunt adăugate ca și elemente copil ale (?) unui obiect (?) + (CreateJS!!)
                </p>
                <p>
                    In plus, personajul care poate fi controlat de catre utilizator este centrat in permanență, restul
                    elementelor, mișcându-se în funcție de deplasarea
                    acestuia. Alte persoaneje ale celorlalți eventuali utilizatori sunt desenate doar daca sunt primite
                    coordonate ale poziției acestora pe ecranul
                    clientului curent. Inamicii sunt generați aleator (+ alte detalii ale designului) si se vor deplasa
                    înspre coordonatele jucătorului.
                </p>
                <p>
                    Atât utilizatorul cât și unii inamicii au acces la crearea unor proiectile. Clientul poate crea câte
                    un proiectil la fiecare clic, iar monștrii
                    la un anumit interval. Proiectilul este un sprite care + (informatii despre el)
                </p>

                <p>
                    În funcție de condițiile temporale si meteorologice, pe canvas este adaugată o animație (+detalii)
                </p>
            </section>


            <section id="client-side-services">
                <h4>Serviciile pe partea de client</h4>
                <p>
                    Pe partea de client se face apel atât la servicii API REST interne, deținute de către server, cât și
                    la servicii externe.
                </p>
                <p>
                    Clientul trimite la începutul jocului o cerere către server pentru primirea datelor temporale și a
                    condițiilor meteorologice în funcție
                    de coordonatele curente. Clientul așteaptă răspunsul serverului și in funcție de timp și vreme
                    încarcă în canvas animația pentru zi sau noapte
                    și eventualele animații pentru vreme ploioasă sau ninsoare.
                </p>


                <p>
                    Tot înainte de joc se face si o primă cerere către serviciul extern <a
                        href="https://docs.mapbox.com/">mapbox API</a>, care pentru o pereche de
                    coordonate primite va întoarce în format JSON o colecție de caracteristici, printre care sunt
                    incluse clădiri, drumuri și spații care conțin apă.
                    Aceste date vor fi folosite pentru desenarea hărții de joc. Pe parcursul jocului, in funcție de
                    deplasarea utilizatorului se vor face cereri
                    suplimentare pentru noi elemente ale hartii.
                </p>

                <p>
                    Clasamentul este obținut prin apelarea unui serviciu intern al serverului, care va întoarce un numar
                    de jucători online ordonați descrescător după
                    punctaj. O descriere a locației curente a utilizatorului este obținută tot de pe server, clientul
                    putând afla numele celei mai apropiate străzi,
                    clădiri sau monument din imediata vecinătate a jucatorului.
                </p>

                <p>
                    La finalul jocului este apelat un alt serviciu al serverului, care va întoarce clasamentul
                    clientului raportat la toți utilizatorii care au jucat
                    vreodată jocul.
                </p>

            </section>
        </section>
        <section id="server">
            <h3>Server</h3>
            <p>
                Aplicația server care deservește utilizatorii a fost creată utilizatând <q>Node JS</q> și folosind
                standardul MVC. (? ar mai trebuii detalii?)
            </p>

            <section id="mvc">
                <h4>Structura serverului</h4>
                <p>
                    (Aicea cred ca ar fi mai bine ca Stefan sa explice, ca el am facut acest MVC)
                </p>


            </section>

            <section id="server-apis">
                <h4>Serviciile puse la dispozitie de catre server</h4>
                <p>
                    Aplicația server pune la dispoziția utilizatorilor servicii care implementează principiul API REST
                    (? bold text??), acestea putând fi accesate de
                    către clienți prin metoda HTTP GET.
                </p>

                <p>
                    Serverul ofera un serviciu de aflare a timpului și a spațiului în funcție de coordonate geografice
                    trimise de către utilizatori. Aceste date sunt
                    oferite de către server prin apelarea la rândul lui a altor servicii externe, dar în caz de eroare a
                    apelarii aplicatia server poate calcula
                    matematic timpul unui client in functie de ora curenta si distanțarea acestuia față de Greenwich.
                </p>

                <p>
                    Clasamentul tuturor utilizatorilor online este reținut de către server, acesta trimițând-ul și
                    clienților. Punctajul clientilor este obtinut prin
                    intermediul comunicarii continue a acestora a propriului punctaj utilizand tehnologia
                    <q>SocketIO</q> (??poate trebuie alte taguri), iar serverul
                    îi ordonează descrescător.
                </p>

                <p>
                    De asemenea serverul pune la dispoziție un serviciu de întoarcere a celor mai mari punctaje
                    înregistrate în baza de date pe tot parcursul istoricului
                    jocului și a poziției clientului curent în funcție de ceilalți jucători.
                </p>
            </section>

            <section id="server-side-services">
                <h4>Serviciile folosite de catre server</h4>
                <p>
                    Pentru a deservi unele cereri ale clienților, serverul utilizează la rândul lui servicii API REST
                    externe.
                </p>
                <p>
                    Timpul specific unor coordonate spațiale este obținut prin folosirea serviciului pus la dispozitie
                    de<a href="https://dev.virtualearth.net">virtualearth</a>,
                    iar vremea prin folosirea <a href="https://api.openweathermap.org/">openweathermap</a>. De asemenea,
                    pentru descrierea locației curente ale
                    clienților este folosit un serviciu al <a href="https://api.mapbox.com/">mapbox</a>, care pune
                    pentru un set de coordonate întoarce cele mai apropiate
                    obiective (străzi sau clădiri).
                </p>

            </section>

        </section>
        <section id="game">
            <h3>Mecanica jocului</h3>
            <p>
                „Cea mai complexă și voluminoasă parte a aplicației este reprezentată de desfășurarea jocului.
                Majoritatea resurselor necesare sunt rulate pe partea
                de client, pentru a nu supraîncărca serverul în cazul în care sunt foarte mulți utilizatori.„
            </p>
            <p>
                ?
            </p>

            <section id="mapbox">
                <h4>Harta jocului</h4>
                <p>
                    Fiecare client va reține într-o colecție toate obiectele specifice hărții de joc: clădiri, străzi,
                    zone cu apă. Întrucât este implementat un sistem
                    de coleziune între jucător și clădiri, sunt eliminate din colecție toate clădirile destul de
                    îndepărtate de jucător. Fiecare caracteristică a
                    hărții este transformată intr-un sprite (+detalii).
                </p>

                <p>
                    Fiecare client va reține într-o colecție toate obiectele specifice hărții de joc: clădiri, străzi,
                    zone cu apă. Întrucât este implementat un sistem
                    de coleziune între jucător și clădiri, sunt eliminate din colecție toate clădirile destul de
                    îndepărtate de jucător. Fiecare caracteristică a
                    hărții este transformată intr-un sprite (+detalii).
                </p>

            </section>

            <section id="player-actions">
                <h4>Generarea de evenimente de catre jucator</h4>
                <p>
                    Acest paragraf este despre generarea de evenimente de catre jucator
                </p>


            </section>

            <section id="game-community">
                <h4>Interactiunea jucatorului in mediul online</h4>
                <p>
                    Acest paragraf este despre socket io si !pvp
                </p>


            </section>

        </section>
    </section>


</body>

</html>