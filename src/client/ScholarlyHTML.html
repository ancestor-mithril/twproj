<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="https://w3c.github.io/scholarly-html/css/scholarly.min.css">
    <link rel="icon" href="../sprites/rq-icon.ico" type="image/x-icon" />
    <script src="https://w3c.github.io/scholarly-html/js/scholarly.min.js"></script>
</head>

<body prefix="schema: http://schema.org" style="font-family: calibri !important; font-size: 14pt;">
    <header>
        <h1>Real Quest</h1>
    </header>

    <div role="contentinfo">
        <dl>
            <dt>Autori</dt>
            <dd>
                <a href="https://github.com/blox-dev">Crainiciuc Călin Ștefan</a>
                &amp;
                <a href="https://github.com/firststef">Petrovici Ștefan</a>
                &amp;
                <a href="https://github.com/ancestor-mithril">Stoica George</a>

            </dd>
            <dt>Erori și recomandări</dt>
            <dd>
                <a href="https://github.com/firststef/twproj/issues">Issues and PRs welcome!</a>
            </dd>

            <dt>Licență</dt>
            <dd>
                <a href="">!! nu stiu daca trebuie pus ceva aici???</a>
            </dd>
        </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
        <h2>Concept</h2>
        <p>
            <q>Real Quest</q> este o aplicație-joc care permite utilizatorilor să se materializeze într-un tărâm mistic,
            copie a lumii reale, pentru a explora și vâna monștrii care vor să elimine orice formă de viață.
        </p>
    </section>
    <section id="introduction" role="doc-introduction">
        <h2>Introducere</h2>
        <p>
            Jocul <q>Real Quest</q> apelează la servicii web pentru a prelua informații despre locația utilizatorului și
            mediul în care se află, simulând mișcarea acestuia pe o hartă. Elementele spațio-temporale reale sunt
            însoțite de monștrii virtuali, care vor ataca jucătorul.
        </p>
        <p>
            Clientul poate să exploreze împrejurimile, orientându-se dupa detalii precum numele de străzi și de clădiri,
            luptându-se cu monștri pentru a câstiga puncte și a supraviețui cât mai mult.
        </p>
    </section>
    <section id="motivation">
        <h2>Motivație</h2>
        <p>
            Acest sit web reprezintă tema noastră de proiect pentru cursul Tehnologii Web al Facultății de
            Informatică al Universității Alexandru Ioan Cuza. Ideea proiectului a fost adusă de noi, fiind pasionați
            de jocuri, prin care ne-am propus să invățăm cât mai multe despre web în timp ce construim ceva interactiv,
            care să ne placă atât nouă, cât și altora.
        </p>
    </section>
    <section id="problem">
        <h2>Formula proiectului</h2>
        <p>
            Pe baza unui API REST ori GraphQL propriu, să se realizeze o aplicație web de tip joc "Monster hunter"
            utilizând hărți reale preluate de la un serviciu web de cartografiere (ex. Google maps sau
            openstreetmaps.org). În joc vor fi simulate condițiile de vreme exterioare (vreme și luminozitate),
            parametri preluați de asemenea de la servicii web specializate. Locația de start a jucătorului va fi
            preluată prin intermediul API-ului de geolocalizare pus la dispoziție în HTML5 și jucătorul va fi capabil să
            vadă alți jucători pe hartă comunicând în timp real cu serverul utilizând WebSockets.
        </p>
        <p>
            Scopul jocului este de a obține cât mai multe puncte din învingerea inamicilor, monștri ce apar pe harta
            preluată cum s-a menționat mai sus. Inamicii -- folosind o strategie euristică -- se apropie de avatarul 
            jucătorului și dacă acesta nu se ferește de proiectilele lor, viața sa va scădea progresiv ( în concordanță
            cu artileria din dotarea inamicilor) până când va ajunge la zero puncte de vitalitate -- în acest caz,
            jocul se va termina pentru acel jucător și punctajul său este considerat final. În același mod, inamicii
            pot fi învinși prin scăderea punctelor de vitalitate prin contactul cu proiectilele jucătorului. La
            finalul jocului se va afișa un clasament global al jucătorilor și punctajele lor.
        </p>
        <p>
            Sistemul va furniza în timp real clasamentul global al primilor N jucători și punctajele lor (minimal, în
            format XML, CSV). De asemenea se va permite descărcarea într-un format specific traiectoriilor GPS (ex.
            format GPX) a traseului parcurs de jucător în lumea reală.
        </p>
    </section>
    <section id="game">
        <h2>Implementarea jocului</h2>

        <section id="preparation">
            <h3>Pregătire și considerente</h3>
            <p>Primul pas a fost documentarea legată de api-urile pe care le vom utiliza. Am utilizat 3 api-uri: pentru
                timp, vreme și geolocatie. Api-urile aparțin domeniilor <a href ="https://dev.virtualearth.net">dev.virtualearth.net</a>,
                <a href ="https://openweathermap.org">openweathermap.org</a> și <a href ="https://mapbox.com">mapbox.com</a>.
                Serverul preia informațiile necesare clientului, iar aplicația client comunica REST cu serverul prin
                api-ul nostru pentru a inițializa condițiile exterioare și harta. Vom detalia utilizarea
                lor în capitolele următoare.</p>

            <p>Am început implementarea prin construirea mecanicilor de bază a jocului. Platforma noastră de dezvoltare
                fiind Web-ul, mai specific, formatul HTML5, am ales ca tehnologie prinicpală HTML5 Canvas. Pentru acest
                joc, aveam nevoie de:
                <div style="padding-left:3em;">
                - o modalitate prin care să desenăm forme geometrice în zone diferite (ex. clădirile) <br>
                - folosirea de imagini (sprite-uri pentru personaj, monștri) <br>
                - capturarea comenzilor utilizatorului <br>
                - animații de sprite-uri (pentru mișcarea jucătorului) <br>
                - să putem muta formele geometrice <br>
                </div>
            </p>
            <p>
                Primele 3 cerințe erau îndeplinite nativ de canvas, însă pentru următoarele două lucrurile nu erau așa
                de simplu de realizat.
            </p>
            <p>
                În primul rând animațiile trebuiau realizate prin împărțirea foii de animație (spritesheet) în mai multe
                cadre, și înlocuirea cadrului curent la un anumit interval, în funcție de viteza animației.
            </p>
            <p>
                În al doilea rând, mutarea entităților desenate pe ecran necesită o arhitectură arborescentă, în care
                fiecare nod copil se orienta relativ la părintele său. Un exemplu de ce este nevoie de aceasta: știm că
                pentru a observa efectul de mișcare a personajului trebuie să observăm o translație a obiectelor din
                interiorul lumii pe măsură ce jucătorul se mișcă, și de asemenea trebuie că acesta să rămână în mijlocul
                ecranului, pentru ca utilizatorul să vadă la fel de mult din hartă pe măsură ce o parcurge. Pentru a
                crea acest efect în interiorul lumii 2d create, observăm că vom avea nevoie de un nod părinte, care
                conține obiectele lumii, inclusiv personajul, și trebuie să mutăm personajul relativ la acest nod, în
                funcție de input. Ceea ce nu este așa de evident este că tot în același timp trebuie să mutăm și lumea
                cu totul, pentru a urmări personajul și a-l menține în mijloc (nu avem în canvas conceptul de cameră
                virtuală, care poate să inspecteze obiecte într-o locație oarecare, ci noi desenăm pe un viewport, și
                deci trebuie să mutăm obiectele). Fără o arhitectură și o implementare care să ne ofere suportul pentru
                relațiile de tip părinte-copil, lucrul acesta ar fi fost extrem de dificil.
            </p>
            <p>                
                În urma realizărilor acestor două cerințe, ne-am dat seama că o implementare elaborată a
                acestora ar dura foarte mult. Din acest motiv, am căutat o implementare open-source ca să ne ajute. Așa
                am descoperit <a href="https://createjs.com/">CreateJS</a>, o librărie cu o licență deschisă și care are
                implementări esențiale pentru jocul nostru.
            </p>
        </section>
        <section id="createjs">
            <h3>Cum am folosit <a href="https://createjs.com/">CreateJS</a></h3>
            <p>
                Librăria permite să instanțiem forme geometrice și imagini animate (sprite-uri) prin construirea de
                obiecte. Principiul de bază este următorul: nodul rădăcină este instanțiat ca un obiect de tip Stage,
                și pentru fiecare copil adăugat lui, nodul părinte îl va orienta în funcție de poziția proprie și
                deplasament.
            </p>
            <p>
                Cum pentru proiect exista restricția de a nu folosi decat librarii, am avut grijă ca alegerea noastră să
                nu fie framework, si am judecat că aceasta îndeplinește condiția luând în considerare următoarele:
                <div style="padding-left:3em;">
                - funcțiile din createjs reprezintă <> wrappere <> peste funcțiile clasice de desenat pe canvas, pastrând
                declarații similare cu cele din api-ul original.<br>
                - clasele din createjs pot fi instanțiate de noi când dorim, având control complet asupra obiectelor din
                lume <br>
                - createJs nu rulează independent de codul nostru, poziția obiectelor pe canvas se actualizează doar
                când apelăm stage.update(), stage fiind tot un obiect instanțiat de noi.
                </div>
            </p>
            <p>
                CreatJs are un obiect folosit pentru optimizare pe browser, Ticker, care are un rol de timer - calculează
                în funcție de frecvența cadrelor pe care o dorim, când trebuie să apelăm
                bucla principală (funcția de actualizare) a jocului, care este definită de noi.
            </p>
            <p>
                După ce am capturat tastele apăsate de utilizator și am introdus o imagine pentru caracter, am reușit să
                creăm un personaj care se putea orienta in spațiu.
            </p>
        </section>
        <section id="map">
            <h3>Realizarea hărții</h3>
            <p>  
                API-ul de geolocație preia coordonate pentru străzi, clădiri, și mase de apă și le creează ca obiecte pe hartă.
                Ordinea în care desenăm obiectele creează și efectul de stratificare, necesar pentru noi pentru ca jucătorul să
                se poziționeze deasupra străzilor și nu sub acestea. Modul în care preluăm coordonatele este descris în secțiunea
                de mai jos, despre <>Mapbox<>. Coordonatele pe care le primim sunt puse în vectori sau multivectori de
                coordonate. Un vector de coordonate reprezintă conturul unei străzi,clădiri sau mase de apă. Coordonatele
                clădirilor sunt păstrate în două locuri: prima dată ca și formă geometrică pe ecran, iar a două oară
                într-un vector ca să ne dăm seama când o clădire a fost deja primită și desenată, și să calculăm
                coliziunile cu jucătorii.
            </p>
            <p>
                După ce am adăugat clădirile, am adăugat și un algoritm pentru coliziune, la început foloseam o librărie cu
                un algoritm bazat pe intersecție de poligoane, dar după, am renunțat la ea întrucât caluclele erau realizate
                prea lent și am făcut o implementare mai optimă, calculând distanțe față de muchiile clădirii. Am adăugat
                două optimizări pentru coliziune, prima calculează limite pentru clădire și se asigură că vom face operația
                de calcul de coliziune (care este costisitoare) doar în interiorul acestei limite, iar a doua calcula intr-un
                interval limitele clădirilor și elimina clădirile îndepărtate, aplicând coliziunea doar pe cele care erau în raza
                de acțiune a jucătorului.
            </p>
        </section>
        <section id="weather">
            <h3>Afișarea vremii</h3>
            <p>
                Apelând serviciile pentru timp și vreme, având ca parametru locația curentă a jucătorului,
                distingem tipul vremii: însorit, înnourat cu ploaie, ninsoare și tipul de luminozitate: luminos sau
                întunecat. În cazul în care serviciul eșuează, am implementat o funcție care calculează aproximativ ora pe glob
                după deplasarea față de Greenwich și o întoarce.
            </p>
            <p>
                Pentru animația de ninsoare și ploaie, a fost necesar să folosim api-ul nativ pentru setări
                mai avansate: ploaia trebuia să aibă o animație, și de asemenea, pentru a optimiza sprite-ul (să nu avem
                o imagine mare formată din imagini mici repetate), buffer-ul sprite-ului trebuia repetat pe tot ecranul.
                În plus, am explicat mai sus că pentru a crea efectul de mișcare, trebuie să mutăm personajul, dar și
                lumea, ca să păstrăm în mijlocul ecranului caracterul. Doar că lumea trebuie mutată în sens invers mișcării
                personajului. Deci, trebuia să deplasăm originea imaginii cu aceeași distanță de deplasare a jucătorului.
                Clasele din CreateJS pot folosi funcții trimise de noi în care apelăm funcțiile de canvas native, acesta
                fiind modul de lucru pentru efectele complexe. Am realizat o astfel de funcție, CreateJS-ul se asigură
                de schimbarea animației iar noi desenăm pe tot ecranul animația curentă și cu deplasamentul potrivit
                mișcării.
            </p>
        </section>
        <section id="loading">
            <h3>Incărcarea resurselor</h3>
            <p>
                Pe lângă api-urile care sunt accesate la început, încarcă imaginile pentru jucător,
                monștri etc. Cum această încărcare se realizează asincron, nu știm exact care dintre apelurile asincrone
                se va termina primul sau în ce ordine. Trebuie să așteptăm câteva secunde pentru ca acestea să se
                termine, și se vedea o pagină goală până începea jocul, așa că am creat o pagină temporară de încărcare
                și am creat PageLoader, o clasa care înregistrează funcții asincrone și apelează un <>callback<> după ce
                toate funcțiile sunt pregătite. Am adăugat și pictograme care să arate progresul, dacă s-a încărcat sau
                nu resursa respectivă.
            </p>
            <p>
                Imaginile se încarcă cu ajutorul unei clase din createjs, LoadQueue. Buffer-ul primit este folosit
                apoi la crearea din animații prin împărțirea ei în secțiuni, în funcție de dimensiunea cadrelor și
                numărul lor.
            </p>
            <p>
                Când PageLoader termină așteparea, jocul începe.
            </p>
        </section>
        <section id="mechanics">
            <h3>Mecanicile de bază ale jocului. Interacțiunea cu inamicii.</h3>
            <p>
                Scopul jocului este obținerea unui punctaj cât mai mare. Acesta depinde de câți monștri ai învins și cât
                de mult ai rezistat în joc. Jucătorul se deplasează cu ajutorul tastelor WASD și poate arunca proiectile
                prin alegerea direcției folosind mouse-ul. Jocul se termină când viața caracterului ajunge la 0, adică
                toată bara roșie din stânga-sus a ecranului se golește.
            </p>
            <p>
                În cazul detectării de coliziune cu o clădire, jucătorului nu i se va permite deplasarea spre aceasta.
                Monștrii sunt de două tipuri, primul tip poate lansa proiectile spre personaj, iar al doilea tip este
                mult mai rapid, însă nu are proiectile. Monștrii blochează trecerea, iar dacă sunt în contact cu
                jucătorul, acesta pierde puncte de vitalitate.
            </p>
        </section>
        <section id="bonuses">
            <h3>Bonusuri</h3>
            <p>
                Pe hartă apar din când în când anumite iconițe care reprezintă un avantaj (uneori temporar) pentru
                jucător: sacul de bani reprezintă 50 de puncte în plus, papucul cu aripi oferă câteva secunde de viteză
                dublă, iar cheile mov pot "deschide" clădirile, adică jucătorul poate să treacă prin ele. Cheile sunt
                stivuibile, dar papucii resetează intervalul de viteză la contact.
            </p>
        </section>
        <section id="art">
            <h3>Artă si design</h3>
            <p>
                Un joc este un proiect foarte laborios, pentru că este format din multe elemente: ideea jocului,
                cât de distractivă este aceasta, design-ul jocului, dacă resursele dau un aspect estetic împreună
                (consistență), mecanica de baza a jocului, cât de echilibrate sunt câștigurile față de efortul depus de
                jucător, cât de accesibile sunt controalele etc. Am încercat să avem în vedere toate aceste aspecte,
                realizând cât mai mult din fiecare.
            </p>
            <p>
                Resursele grafice au fost desenate de noi (imaginea personajului și a monștrilor, animațiile, cele
                două imagini cu eroul de pe pagină principală, imaginile pentru bonusuri), dar pot fi folosite de
                cine dorește.
            </p>
            <p>
                De asemenea am scris si o introducere pe pagina principala, pentru a oferi un context jocului. 
            </p>
            <p>
                Pentru majoritatea jocurilor, interfața jocului (UI-ul), este integrată în aceeași tehnologie ca și restul
                jocului. Însă, în loc să o facem din dreptunghiuri, chenare, text, butoane desenate în interiorul
                canvas-ului, am decis să folosim html-ul și css-ul. Până la urmă, aceasta este cea mai utilizată
                tehnologie pentru realizarea de interfețe și este foarte bine testată. În plus, puteam să ne folosim
                direct de cunoștințele legate de front-end, în loc să calculăm și să implementăm noi un sistem pentru
                interfață.
            </p>
        </section>
        <section id="gameEnd">
            <h3>Sfârșitul jocului</h3>
            <p>
                Când jucătorul își pierde toate punctele de vitalitate, jocul afișează punctajul acestuia, locul său
                în clasament și primii jucători. De aici ei pot descărca traseul parcurs si clasamentul primilor 10 jucători,
                in funcție de scor.
            </p>
        </section>
        <section id="formats">
            <h3>Formatele exportate</h3>
            <p>
                Pe parcursul jocului sunt salvate punctele geografice prin care trece jucătorul, iar la final el poate
                descărca un fișier GPX cu traseul parcurs. De asemenea, pe pagina de final, utilizatorul poate descărca
                clasamentul primilor 10 jucători în format CSV.
            </p>
        </section>
        <section id="mobile">
            <h3>Versiunea de mobil</h3>
            <p>
                Pentru versiunea de mobil am adăugat o implementare open-source numită JOY.JS pentru un joystick
                html5[1]. Pe ecranele mici, sunt 2 joystick-uri: cel din dreapta este pentru mișcarea personajului, iar
                cel din stânga, dacă nu este în starea default, trimite un proiectil în direcția în care este îndreptat.
            </p>
        </section>
        <section id="mapbox">
            <h3>Hartile din Mapbox GL JS</h3>
            <p>
                Unul din api-urile pe care le-am folosit a fost cel de geolocatie. Acesta ne intorcea cele mai apropiate
                obiecte (strazi, cladiri, monumente, etc). Insa problema era ca nu ne intorcea coordonatele conturului
                acestora. Am cautat suplimentar fata de acesta alt serviciu si am realizat la dupa ce pornisem proiectul
                ca nu exista un api pentru delimitarile
                cladirilor/ monumentelor/ formelor de relief, care sa fie accesibil prin cerere http. Pana si google,
                care are o colectie foarte mare de harti si alte api-uri legate de acestea, nu avea un astfel de
                serviciu.
                Nici Openstreetmaps, nici alte domenii. Si pe noi ne-a intrigat acest aspect, dar am descoperit un
                serviciu de la Mapbox care permitea descarcarea de fisiere compresate care contineau astfel de
                informatii.
                Insa in ciuda efortului depus, nu am reusit sa despachetam formatul respective (.pbf/.mvt), la inceput
                folosind gunzip, sau alte librarii, in javascript, in python. Formatul pe care Mapbox il punea la
                dispozitie pare ca se despacheta diferit fata de .pbf-urile normale, apartinand google. Un alt domeniu,
                openstreetmaps, mentiona ca are datele respective, dar printre implementarile oferite de ei pentru
                lucrul cu aceste fisiere, nu am gasit
                nicio implementare viabila. Cand spunem ca nu erau viabile, ne referim la mai multe probleme, in primul
                rand, noi doream initial ceva care sa fie sub forma de api, sau daca trebuia sa despachetam noi
                formatele, sa avem si o librarie care sa faca asta, dar unele implementari erau sdk-uri, librarii cu
                licenta non-open-source, sau scrise in c++ (si nu voiam server in c++).
            </p>
            <p>
                Dar am gasit o solutie pana la urma. Totusi hartile pe care le vedem noi pe site-uri cum fac?, ne-am
                intrebat. Am descoperit ca intr-o implementare pentru harti embedded folosind canvas pentru web, era
                posibil pentru noi sa interogam harta la momentul curent si sa intoarcem coordonatele cladirilor. Dar,
                din pacate, cand am incercat sa luam aceasta librarie sa o punem pe server ca sa incapsulam intr-un api
                propriu functionalitatea, am descoperit ca libraria era incompatibila cu node.js - era doar pentru web.
                Si da, am incercat, in primul rand sa reparam dependintele, dupa sa emulam un browser pe serverul de
                node, insa, dupa multe incercari, am renuntat. In final, pentru a construi harta noastra, ne folosim de
                harta celor de la Mapbox. Libraria este open-source, insa cum despacheteaza exact formatul, nu am reusit
                sa reproducem, am investigat si am trecut din nou prin implementari si prin gunzip si prin librarii, dar
                a trebuit sa alegem ca solutie finala utilizarea acestei librarii pe front-end. Daca am fi reusit, am fi
                putut sa mutam cladirile, interactiunea cu ele pe server, si sa facem jocul si mai performant, si chiar
                ne-am fi dorit acest lucru. Insa aveam doar optiunea de frontend, iar ideea de a transmite coordonatele
                serverului pentru a controla el coliziunea nu ar fi fost un lucru benefic.
            </p>
        </section>
        <section id="multiplayer">
            <h3>Multiplayer</h3>
            <p>Un lucru interesant la un joc retro este sa ai capabilitati multiplayer. In aplicatia noastra jucatorii
                isi pot observa unul celuilalt pozitia, orientarea curenta si pot interactiona prin intermediul
                chat-ului. Totusi, ei nu se vor putea ciocni sau lupta monstri impreuna. Calculele nu se realizeaza la
                nivel de server, ci jocul este client-based, din cauza ca nu puteam muta calculele pe server,
                desi daca reuseam, am fi fost si mai multumiti.
            </p>
            <p>
                La inceperea jocului se realizeaza o conexiune cu serverul prin SocketIO (detalii mai jos). Clientul
                trimite la un interval de timp, la inceput mai mare (1s), coordonatele serverului. Daca jucatorul are in
                jurul sau pe altcineva, acest interval se micsoreaza la o anumita valoare, astfel incat coordonatele sa
                fie transmise mai repede pentru a fi actualizate intre clienti. Acest mod de comunicare reprezinta o
                optimizare pentru a nu folosi intens resursele atunci cand jucatorii nu au pe cineva in proximitatea
                lor.
            </p>
            <p>
                Odata cu coordonatele trimise, jucatorii trimit si punctajul curent, iar serverul realizeaza un
                clasament live al jucatorilor pe care il ofera prin api. Pe UI-ul jocului in coltul din dreapta sus este
                o tabela care se actualizeaza live apeland acest api.
            </p>
            <p>
                La deconectare, serverul intelege ca sesiunea de joc a utilizatorului s-a terminat si inregistreaza in
                baza de date ultimul punctaj obtinut. Clientul va obtine prin apelarea api-ului locul sau in clasament
                dupa inserare si top-ul jucatorilor.
            </p>
        </section>
    </section>
    <section id="app">
        <h2>Implementarea aplicatiei</h2>

        <section id="site">
            <h3>Realizarea paginilor site-ului</h3>
            <p>
                Pe prima pagina este formularul de intrare in joc. La incarcarea paginii, browser-ul va cere permisiunea
                pentru geolocatie. In cazul in care utilizatorul isi da acordul pentru preluarea datelor, se completeaza
                in formularul de inceput de joc coordonatele sale. Altfel el ramane cu anumite coordonate default,
                acestea fiind o anumita zona din Iasi, orasul in care a fost implementat acest proiect. Dupa ce un
                utilizator isi scrie un username dorit,
                este directionat pe pagina jocului. Transmiterea coordonatelor si a numelui de utilizator intre pagini
                este realizata cu LocalStorage pe browser-ele care suporta aceasta, altfel prin intermediul parametrilor
                in adresa url.
            </p>
            <p>
                Paginile au fost analizate cu grija sa permita
            </p>
        </section>
        <section id="server">
            <h3>Pornirea server-ului</h3>
            <p>
                Intrucat incepusem sa invatam javascript cu implementarea jocului si din operatiile de frontend, ne-am
                hotarat sa pastram limbajul si sa apelam la tehnologiile NodeJS. De asemenea aveam la inceput intentia
                sa integram algoritmii pentru coliziune si alte functionalitati ale jocului pe server, pentru
                performanta, insa s-a dovedit ca trebuie sa le pastram pe client.
            </p>
            <p>
                Serverul trebuia atat sa intoarca fisierele pentru pagini, dar trebuia si sa comunice cu clientul prin
                api de tip REST. La inceput faceam un switch pentru a detecta daca era o resursa sau un api si apelam
                functiile potrivite. Un fisier de configurare pe server in format json ne spunea ce fisiere avem, ruta
                pe care puteau fi accesate si tipul lor. Insa dupa am renuntat la acest fisier de configurare pentru
                pagini si recurs la o implementare mai organizata, cea de tip MVC.
            </p>
        </section>
        <section id="mvc">
            <h3>Arhitectura MVC</h3>
            <p>
                Pentru a realiza o arhitectura MVC am creat clasele Router, Controller si Model. Router-ul face legatura
                dintre ruta la care primim request-ul si controller-ul care trebuie sa intoarca raspunsul. Sunt doua
                tipuri de controllere: ApiController si ResourceController. ResourceController se ocupa cu citirea
                fisierelor resursa si trimiterea lor, iar ApiController executa o anumita procedura si intoarce
                rezultatul acesteia. Controller-ele comunica cu clasa Model, responsabila cu accesul la baza de date si
                logica aplicatiei. Pentru fisierele pe care trebuiau aplicate template-uri, am fi putut utiliza o clasa
                View care sa substituie campurile ce aveau continutul '{{ variabila }}' cu valoarea respectiva din
                Model, insa noi am folosit mai mult api-uri ca sa ne umplem continutul, avand nevoie de versiunea live,
                si nu versiunea la incarcare.
            </p>
            <p>Model foloseste o clasa asemanatoare cu PageLoader, ApiLoader, si el cu rol de a incarca asincron
                api-urile si a intoarce in acelasi timp raspunsul. Diferenta este ca in timp ce PageLoader stoca datele
                primite la nivel global, ApiLoader nu poate pune in variabile global rezultatele si le ofera
                callback-urilor un context local in care sa-si puna rezultatul interogarilor si de asemenea rezolva
                request-ul primit doar daca toate callback-urile au reusit, iar in
                caz contrar trimite un cod de eroare.</p>
        </section>
        <section id="socketio">
            <h3>Comunicarea prin SocketIO</h3>
            <p>Websocket-urile permit comunicarea in timp real cu clientii, lucru necesar in momentul in care vrem
                ca jucatorii sa se poata vedea unii pe ceilalti in acelasi timp. Pe aceasta tehnologie se bazeaza
                libraria SocketIO, pe care am integrat-o cu jocul nostru, atat pe partea de server cat si pe partea de
                client. In momentul conectarii se creeaza socket-uri, clientul si serverul ramanand conectati pe tot
                parcursul jocului. Comunicarea incepe cu clientul trimitand o cerere HTTP catre server cu
                continutul"Upgrade: websocket". Daca serverul accepta, comunicarea se realizeaza din acel moment cu
                protocolul WS, care trimite si accepta pachete mai mici, pentru a creste viteza. </p>
            <p>
                Serverul si clientul isi pot trimite unul altuia evenimente si un buffer de date odata cu acel
                eveniment.
            </p>
            <p>Cea mai des implementata aplicatie a websocket-urilor sunt chat-urile, si am vrut sa includem si noi o
                fereastra de chat. Asa putem folosi functionalitatea de broadcast a serverului de websocket-uri, care
                atunci cand primeste un eveniment de la client ca s-a trimis un mesaj, face broadcast pentru toti
                clientii conectati cu datele primite.</p>
        </section>
        <section id="bd">
            <h3>Baza de date</h3>
            <p>Pentru baza de date am folosit MongoDB, fiind o alegere recomandata pentru serverele de NodeJS, si dorind
                sa experimentam cu o baza de date NoSQL. De asemenea serviciile MongoDB ne permiteau sa folosim o baza
                de date in cloud gratis, si asta ne-a permis sa nu mai ingreunam proiectul cu o configuratie locala a
                bazei de date, noi lucrand fiecare separat.</p>
        </section>
        <section id="api">
            <h3>Api-urile create</h3>
            <p>Aplicatia foloseste activ informatiile gasite pe server si le preia comunicand REST cu acesta.</p>
            <section id="livescores">
                <h4>Livescores</h4>
                <p>Acest api primeste ca parametru in url o constanta "count", si intoarce primele "count" inregistrari
                    de utilizatori din lista de jucatori activi, sortati dupa punctaj. Inregistrarile sunt sub forma
                    unui json cu un vector de obiecte.</p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
[{"username": "player1", "currentPoints":"100"}, {"username":"player2", "currentPoints": "11"}...]
                    </pre>
                </figure>
            </section>
            <section id="leaderboards">
                <h4>LeaderBoards</h4>
                <p>Acest api returneaza primii "count" jucatori dupa punctaj care au terminat jocul, si care au un
                    punctaj mai mare decat parametrul optional "myScore". Pe langa vectorul de obiecte, daca am vrea sa
                    stim cati jucatori sunt cu punctaj mai mare decat myScore, dar totusi sa intoarcem doar "count"
                    elemente, api-ul intoarce numarul de astfel de jucatori sub campul "myPlace".
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"players":[{"username": "player1", "currentPoints":"100"}, {"username":"player2", "currentPoints": "11"}...], "myPlace":"1"}
                    </pre>
                </figure>
            </section>
            <section id="weathertime">
                <h4>Weather and Time</h4>
                <p>Api-ul ofera informatii despre vreme si timp la coordonatele trimise ca parametri: ["lat", "lng"]. In obiectul "weather" sunt mai multe informatii, dar jocul foloseste in special campul "main", care poate fi ["Rain", "Snow", etc.] si campul "time" care precizeaza ora in minute.
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"weather": {...},"time": 900}
                    </pre>
                </figure>
            </section>
            <section id="nearby">
                <h4>NeabyFeatures</h4>
                <p>Acest api intoarce o descriere a locației curente a utilizatorului (trimise ca ["lat", "lng"]),
                    clientul putând afla numele
                    celei mai apropiate străzi, clădiri sau monument din imediata vecinătate a jucatorului. Mesajele
                    sunt personalizate cu formulari misterioase cu rolul de a pastra o nuanta de poveste intr-un context
                    realistic.</p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"name": "Strada Palas","topText": "","bottomText": " is in your sight"}
                    </pre>
                </figure>
            </section>
            <section id="aconfig">
                <h4>Config</h4>
                <p>Nu in ultimul rand este api-ul de config, care intoarce clientului parametri pentru joc, asa cum au
                    fost stabiliti de administator.</p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"maxNrOfMonsters":10,"isNight":false,"rain":false,"snow":false,"playerMaxHealth":100,"moneyPowerUpValue":50,"displacement":0.000002,"speedDisplacement":1.45,"scale":2.5,"leaderBoardCount":7}
                    </pre>
                </figure>
            </section>
        </section>
        <section id="config">
            <h3>Modulul de configurare</h3>
            <p>
                Ca si administratori ai serverului, putem ajusta anumiti parametri ai jocului in functie de feedback-ul
                pe care il primim de la jucatori sau daca observam un mod prin care putem imbunatati experienta jocului.
                Aceasta o facem printr-un fisier de configurare, care contine constante pentru joc: cati monstri sunt
                creati la inceput, numarul de puncte de viata ale jucatorului, se poate seta o vreme globala pentru joc,
                la ce scala este desenata harta etc.
            </p>
        </section>
    </section>
    <section id="development">
        <h2>Procesul de dezvoltare</h2>

        <section id="repo">
            <h3>Github</h3>
            <p>
                Pentru managementul codului sursa am folosit Github. Aceasta platforma a venit cu o multime de avantaje,
                si am fost foarte multumiti de ea. Pe langa posibilitatea de a vedea in browser codul sursa si a
                modificarilor facute pe parcursul proiectului, Github ne-a permis sa facem si un Project Board. Pe acest
                board noi puteam stabili si crea task-uri, ca sa stim care este partea din proiect de care trebuie sa se
                ocupe fiecare. De asemenea ne arata si statistici, cat de mult am scris, cat de des, si cat mai avem
                pana terminam toate cerintele.
            </p>
        </section>
        <section id="static">
            <h3>Analiza statica</h3>
            <p>DeepScan este un analizator static pentru javascript, si ne-a permis sa observam erori sau sa ne
                imbunatatim codul. De exemplu acesta ne spunea cand o variabila este declarata dar nu este folosita
                nicaieri, cand o anumita conditie ajungea sa fie indeplinita mereu, etc. DeepScan ofera analiza gratis
                la conectarea cu Github prin programul Github Student Developer Pack.
            </p>
        </section>
        <section id="deployment">
            <h3>Lansare continua (Continuous Deployment)</h3>
            <p>
                Probabil cea mai folositoare metoda de testare pentru proiect a fost ca am putut avea versiunea live a
                proiectului inca de la inceput. Folosind oferta gratis de la DigitalOcean in parteneriat cu Github, am
                putut configura un vm pe care sa pornim serverul nostru. La scurt timp, am adaugat o optiune in Github
                ca la fiecare push pe branch-ul master sa actualizam serverul. Am facut asta utilizand o actiune
                open-source de la Github prin care putem sa inseram o cheie ssh care sa se conecteze la masina virtuala
                si sa faca un git pull, dupa care sa reporneasca serverul. Initial eram reticenti la folosirea unei chei
                ssh pe un repo public, gandindu-ne ca oricine ar putea sa ia cheia si sa se conecteze la server, insa
                Github a implementat foarte inteligent solutia pentru astfel de probleme: pe Github exista o sectiune
                numita "Secrets". Aici se pot pune date de tip nume-valoare, date care pot fi folosite in actiuni, iar
                modul in care acestea ofera securitate sistemului este ca odata inserata o valoare, ea nu poate fi
                accesata de niciun membru, ci e posibil sa fie utilizata doar in actiuni. A fost prima data cand am
                implementat o astfel de actiune, dar cei de la Github au facut ca tot procesul sa fie foarte usor si la
                indemana de realizat, iar in final, am reusit. Serverul se actualiza la fiecare schimbare care o puneam
                pe repo.
            </p>
        </section>
        <section id="logging">
            <h3>Inregistrarea erorilor in log</h3>
            <p>
                Atunci cand serverul nostru este la distanta, se poate intampla ca ceva sa mearga rau, iar noi sa nu
                realizam sau sa putem vedea output-ul pentru ca nu avem acces imediat la acea masina. Pentru asta am
                implementat ca la fiecare pornire,
                serverul sa faca un fisier de log intr-un folder, si sa il numeasca utilizand data si ora la care a fost
                pornit. Astfel, daca vom avea nevoie sa vedem din ce motiv a picat serverul sau daca s-a intamplat ceva
                neprevazut, putem inspecta log-urile.
            </p>
            <p>
                Mai trebuie mentionat ca fisierul de log-uri a trebuit sa-l trecem ca exceptie in .gitignore, pentru ca
                sa nu existe conflicte de vreun fel cand serverul executa pull pe repo (ar fi putut vedea un conflict
                intre doua fisiere de log numite la fel).
            </p>
        </section>
    </section>
    <section id="conclusion">
        <h2>Concluzii</h2>
        <p></p>
    </section>

























    </section>


</body>

</html>