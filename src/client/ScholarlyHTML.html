<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="https://w3c.github.io/scholarly-html/css/scholarly.min.css">
    <link rel="icon" href="../sprites/rq-icon.ico" type="image/x-icon" />
    <script src="https://w3c.github.io/scholarly-html/js/scholarly.min.js"></script>
</head>

<body prefix="schema: http://schema.org" style="font-family: calibri !important;">
    <header>
        <h1>Real Quest</h1>
    </header>

    <div role="contentinfo">
        <dl>
            <dt>Autori</dt>
            <dd>
                <a href="https://github.com/blox-dev">Crainiciuc Călin Ștefan</a>
                &amp;
                <a href="https://github.com/firststef">Petrovici Ștefan</a>
                &amp;
                <a href="https://github.com/ancestor-mithril">Stoica George</a>

            </dd>
            <dt>Erori și recomandări</dt>
            <dd>
                <a href="https://github.com/firststef/twproj/issues">Issues and PRs welcome!</a>
            </dd>

            <dt>Licență</dt>
            <dd>
                <a href="">!! nu stiu daca trebuie pus ceva aici???</a>
            </dd>
        </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
        <h2>Abstracțiune</h2>
        <p>
            <q>Real Quest</q> este o aplicație-joc care permite utilizatorilor să se materializeze într-un tărâm mistic,
            copie de rang secund a lumii reale, pentru a explora
            și vâna monștrii care vor să elimine orice formă de viață.
        </p>
    </section>
    <section id="introduction" role="doc-introduction">
        <h2>Introducere</h2>
        <p>
            Jocul <q>Real Quest</q> apelează la servicii web pentru a prelua informații despre locația utilizatorului și
            mediul în care se află, simulând mișcarea acestuia pe o hartă. Elementele spațiu-temporale reale sunt
            însoțite de monștrii virtuali, care vor ataca jucătorul.
        </p>
        <p>
            Clientul poate să explore împrejurimile, orientându-se dupa detalii precum numele de străzi și de clădiri,
            luptându-se cu monștrii pentru a câstiga puncte și a supraviețuii cât mai mult.
        </p>
    </section>
    <section id="motivation">
        <h2>Motivație</h2>
        <p>
            Acest proiect reprezinta tema noastra de proiect pentru cursul Tehnologii Web al Facultatii de
            Informatica al Universitatii Alexandru Ioan Cuza. Ideea proiectului a fost propusa de noi, fiind pasionati
            de jocuri si dorind sa incercam un proiect venind cu o idee proprie, prin care sa invatam cat mai multe
            despre web in timp ce construim ceva interactiv, care sa ne placa atat noua, cat si altora.
        </p>
    </section>
    <section id="problem">
        <h2>Formula proiectului</h2>
        <p>
            Pe baza unui API REST ori GraphQL propriu, să se realizeze o aplicație web de tip joc "Monster hunter"
            utilizând hărți reale preluate de la un serviciu web de cartografiere (ex. Google maps sau
            openstreetmaps.org). În joc vor fi simulate condițiile de vreme exterioare (vreme și luminozitate),
            parametri preluați de asemenea de la servicii web specializate. Locația de start a jucătorului va fi
            preluată prin intermediul API-ului de geolocalizare pus la dispoziție în HTML5 și jucătorul va fi capabil să
            vadă alți jucători pe hartă comunicând în timp real cu serverul utilizând WebSockets.
        </p>
        <p>
            Scopul jocului este de a obține cât mai multe puncte din învingerea inamicilor, inamici ce apar pe harta
            preluată cum s-a menționat mai sus. Inamicii -- folosind o strategie (euristică) generată prin program --
            tind a se apropia de avatarul jucătorului și dacă acesta nu se ferește de proiectilele lor, viața sa va
            scădea progresiv ( în concordanță cu artileria din dotarea inamicilor) până când va ajunge la zero puncte de
            vitalitate -- în acest caz, jocul se va termina pentru acel jucător și punctajul său este considerat final.
            În același mod, inamicii pot fi învinși prin scăderea punctelor de vitalitate prin contactul cu
            proiectilele/armamentul jucătorului. La finalul jocului se va afișa un clasament global al jucătorilor și
            punctajele lor.
        </p>
        <p>
            Sistemul va furniza în timp real clasamentul global al primilor J jucători și punctajele lor (minimal, în
            format XML, CSV). De asemenea se va permite descărcarea într-un format specific traciectoriilor GPS (ex.
            format GPX) a traseului parcurs de jucator în lumea reală.
        </p>
    </section>
    <section id="game">
        <h2>Implementarea jocului</h2>

        <section id="preparation">
            <h3>Pregătire și considerente</h3>
            <p>Primul pas a fost documentarea legata de api-urile pe care le vom utiliza. Am utilizat 3 api-uri: pentru
                timp, vreme si geolocatie. Api-urile apartin domeniilor dev.virtualearth.net, openweathermap.org si
                mapbox.com. Serverul preia informatiile necesare clientului, iar aplicatia client comunica REST cu
                serverul prin api-ul nostru pentru a initializa conditiile exterioare si harta. Vom detalia utilizarea
                lor cand ajungem la ele in implementare.</p>

            <p>Am început implementarea prin construirea mecanicilor de bază a jocului. Platforma noastră de dezvoltare
                fiind Web-ul, mai specific, formatul HTML5, am ales ca tehnologie prinicpală HTML5 Canvas. Pentru acest
                joc, aveam nevoie de:
                - o modalitate prin care sa desenam forme geometrice in zone diferite (ex. cladirile)
                - folosirea de imagini (sprite-uri pentru personaj, monstri)
                - capturarea comenzilor utilizatorului
                - animatii de sprite-uri (pentru miscarea jucatorului)
                - sa putem muta formele geometrice </p>
            <p>
                Primele 3 cerinte erau indeplinite nativ de Canvas, insa pentru urmatoarele doua lucrurile nu erau asa
                de simple de realizat.
            </p>
            <p>
                In primul rand animatiile trebuiau realizate prin impartirea foii de animatie (spritesheet) in mai multe
                cadre, si inlocuirea cadrului curent la un anumit interval, in functie de viteza animatiei.
                In al doilea rand, mutarea entitatilor desenate pe ecran necesita o arhitectura arborescenta, in care
                fiecare nod copil se orienta relativ la parintele sau. Un exemplu de ce este nevoie de aceasta: stim ca
                pentru a observa efectul de miscare a personajului trebuie sa observam o translatie a obiectelor din
                interiorul lumii pe masura ce jucatorul se misca, si de asemenea trebuie ca acesta sa ramana in mijlocul
                ecranului, pentru ca utilizatorul sa vada la fel de mult din harta pe masura ce o parcurge. Pentru a
                crea acest efect in interiorul lumii 2d create, observam ca vom avea nevoie de un nod parinte, care
                contine obiectele lumii, inclusiv personajul, si trebuie sa mutam personajul relativ la acest nod, in
                functie de input. Ceea ce nu este asa de evident este ca tot in acelasi timp trebuie sa mutam si lumea
                cu totul, pentru a urmari personajul si a-l mentine in mijloc (nu avem in canvas conceptul de camera
                virtuala, care poate sa inspecteze obiecte intr-o locatie oarecare, ci noi desenam pe un viewport, si
                deci trebuie sa mutam obiectele). Fara o arhitectura si o implementare care sa ne ofere suportul pentru
                relatiile de tip parinte-copil, lucrul acesta ar fi fost extrem de dificil.
            </p>
            <p>
                In urma realizarilor acestor doua cerinte din urma, ne-am dat seama ca o implementare elaborata a
                acestora ar dura foarte mult. Din acest motiv, am cautat o implementare open-source ca sa ne ajute. Asa
                am descoperit CreateJS, o librarie cu o licenta deschisa si care avea implementari esentiale pentru
                jocul nostru.
            </p>
        </section>
        <section id="createjs">
            <h3>Cum am folosit CreateJS</h3>
            <p>
                Libraria permitea sa instantiem forme geometrice si imagini animate (sprite-uri) prin construirea de
                obiecte. Principiul de baza este urmatorul. Nodul radacina trebuia instantiat ca un obiect de tip Stage,
                si pentru fiecare copil adaugat lui, nodul parinte il va orienta in functie de pozitia proprie si
                deplasament.
            </p>
            <p>
                Cum pentru proiect exista restrictia de a nu folosi decat librarii, am avut grija ca alegerea noastra sa
                nu fie framework, si am judecat ca aceasta indeplineste conditia luand in considerare urmatoarele:
                - functiile din createjs reprezinta wrappere peste functiile clasice de desenat pe canvas, pastrand
                signaturi similare cu cele din api-ul original
                - clasele din createjs pot fi instantiate de noi cand dorim, avand control complet asupra obiectelor din
                lume
                - createjs nu ruleaza independent de codul nostru, positia obiectelor pe canvas se actualizeaza doar
                cand apelam stage.update(), stage fiind un obiect instantiat de noi
            </p>
            <p>
                Createjs are un obiect folosit pentru optimizare pe browser, Ticker, si are un rol de timer - calculeaza
                in functie de framerate-ul
                pe care il dorim si apeluri la requestAnimationFrame, cand trebuie sa apelam bucla principala (functia
                de update) a jocului, care este definita de noi.
            </p>
            <p>
                Dupa ce am capturat input-ul de la utilizator prin handle-uri pe evenimente de input de la tastatura si
                am introdus o imagine pentru personaj, am reusit sa facem un personaj care se putea orienta in spatiu.
            </p>
        </section>
        <section id="map">
            <h3>Realizarea hartii</h3>
            <p>Harta noastra preia coordonate pentru strazi, cladiri, si mase de apa si le creeaza ca obiecte pe harta.
                Ordinea in care desenam obiectele creeaza si efectul de stratificare, necesar pentru noi ca jucatorul sa
                se pozitioneze deasupra strazilor si nu sub. Modul in care luam coordonatele este descris in sectiunea
                de mai jos, despre Mapbox. Coordonatele pe care le primim sunt puse in vectori sau multivectori de
                coordonate. Un vector de coordonate reprezinta conturul unei strazi/ cladiri/ mase de apa. Coordonatele
                cladirilor sunt salvate in doua locuri: prima data ca si forma geometrica pe ecran, iar a doua oara
                intr-un vector ca sa ne dam seama cand o cladire a fost deja primita si desenata, si ca sa calculam
                coliziunile cu jucatorii.</p>
            <p>
                Dupa ce am adaugat cladirile, am adaugat un algoritm pentru coliziune, la inceput foloseam o librarie cu
                un algoritm bazat pe intersectie de poligoane, dar dupa, am renuntat la ea si am facut noi o
                implementare mai optima, calculand distante fata de muchiile cladirii. Am adaugat doua optimizari pentru
                coliziune, prima calculeaza limite pentru cladire si se asigura ca vom face operatia de calcul de
                coliziune (care este costisitoare) doar in interiorul acestei limite, iar a doua calcula pe un interval
                limitele cladirilor si elimina cladirile indepartate, aplicand coliziunea doar pe cele care erau in raza
                noastra de actiune.
            </p>
        </section>
        <section id="weather">
            <h3>Afisarea vremii</h3>
            <p>
                Apeland serviciile pentru timp si vreme, completand ca si parametru locatia curenta a jucatorului,
                distingem tipul vremii: insorit, innourat cu ploaie, ninsoare si tipul de luminozitate: luminos/
                intunecat. In cazul in care serviciul esueaza, avem o functie care calculeaza aproximativ ora pe glob
                dupa deplasarea fata de Greenwich si o intoarce.
            </p>
            <p>
                Pentru animatia de ninsoare si ploaie, a fost necesar sa folosim api-ul nativ pentru setari
                mai avansate: ploaia trebuia sa aiba o animatie, si de asemenea, pentru a optimiza sprite-ul (sa nu avem
                o imagine mare formata din imagini mici repetate), buffer-ul sprite-ului trebuia repetat pe tot ecranul.
                In plus, am explicat mai sus ca pentru a crea efectul de miscare, trebuie sa mutam personajul, dar si
                lumea, ca sa pastram in mijloc caracterul. Doar ca lumea trebuie mutata in sens invers miscarii
                personajului. Deci, trebuia sa deplasam originea imaginii cu distanta de de plasare a jucatorului.
                Clasele din CreateJS pot folosi functii trimise de noi in care apelam functiile de canvas native, acesta
                fiind modul de lucru pentru efectele complexe. Am realizat o astfel de functie, CreateJS-ul se asigura
                de schimbarea animatiei iar noi desenam pe tot ecranul animatia curenta si cu deplasamentul potrivit
                miscarii.
            </p>
        </section>
        <section id="loading">
            <h3>Incarcarea Resurselor</h3>
            <p>Pe langa api-urile care trebuie accesate la inceput, jocul trebuie sa incarce imaginile pentru jucator,
                monstri etc. Cum aceasta incarcare se realizeaza asincron, nu stim exact care dintre apelurile asincrone
                se va termina primul/ultimul/in ce ordine. Trebuia sa asteptam cateva secunde pentru ca acestea sa sa
                termine, si se vedea o pagina goala la inceput, pana incepea jocul, asa ca am pus o pagina de incarcare
                si am creat PageLoader, o clasa care inregistreaza functii asincrone si apeleaza un callback de
                terminare dupa ce toate functiile sunt terminate. In cazul nostru, noi doream sa afisam jocul cand se
                termina de incarcat, si am adaugat si pictograme care sa arate progresul, daca s-a incarcat sau nu
                resursa respectiva.</p>
            <p>Imaginile se incarca cu ajutorul unei clase din createjs, LoadQueue. Buffer-ul primit este folosit mai
                apoi la crearea din animatii prin impartirea ei in sectiuni, in functie de dimensiunea cadrelor si
                numarul lor.</p>
            <p>Cand PageLoader termina asteparea, jocul incepe.</p>
        </section>
        <section id="mechanics">
            <h3>Mecanicile de baza ale jocului. Interactiunea cu inamicii</h3>
            <p>Scopul jocului este obtinerea unui punctaj cat mai mare. Acesta depinde de cati monstri ai invins si cat
                de mult ai rezistat in joc. Jucatorul se deplaseaza cu ajutorul tastelor WASD si poate arunca proiectile
                prin alegerea directiei folosind mouse-ul. Jocul se termina cand viata caracterului ajunge la 0, adica
                cand toata bara rosie din stanga-sus a ecranului se goleste.</p>
            <p>
                In cazul detectarii de coliziune cu o cladire, jucatorului nu i se va permite deplasarea spre aceasta.
                Monstrii sunt de doua tipuri, primul tip poate lansa proiectile spre personaj, iar al doilea tip este
                mult mai rapid, insa nu are proiectile. Monstrii blocheaza trecerea,iar daca sunt in contact cu
                jucatorul, acesta pierde puncte de vitalitate.
            </p>
        </section>
        <section id="bonuses">
            <h3>Bonusuri</h3>
            <p>Pe harta apar din cand in cand anumite iconite care reprezinta un avantaj (uneori temporar) pentru
                jucator: sacul de bani reprezinta 50 de puncte in plus, papucul cu aripi ofera cateva secunde de viteza
                dubla, iar cheile mov pot "deschide" cladirile, adica jucatorul poate sa treaca prin ele. Cheile sunt
                stivuibile, dar papucii reseteaza intervalul de viteza la contact.</p>
        </section>
        <section id="art">
            <h3>Arta si design</h3>
            <p>Un joc este un proiect foarte laborios, pentru ca este format din foarte multe elemente: ideea jocului,
                cat de distractiva este aceasta, design-ul jocului, daca resursele dau un aspect estetic impreuna
                (consistenta), mecanica de baza a jocului, cat de echilibrate sunt castigurile fata de efortul depus de
                jucator, cat de accesibile sunt controalele etc. Am incercat sa avem in vedere toate aceste aspecte,
                realizand cat mai mult din fiecare.</p>
            <p>
                Resursele grafice au fost desenate de noi (Sprite-ul personajului si al monstrilor, animatiile, cele
                doua imagini cu eroul de pe pagina principala, sprite-urile pentru power-up-uri), dar pot fi folosite de
                cine doreste.
            </p>
            <p>De asemenea am scris si o introducere pe pagina principala, pentru a oferi un context jocului. </p>
            <p>Pentru majoritatea jocurilor, interfata jocului (UI-ul), este integrata in aceeasi tehnologie ca restul
                jocului. Insa, in loc sa o facem din dreptunghiuri, chenare, text, butoane desenate in interiorul
                canvas-ului, am decis sa folosim html-ul si css-ul. Pana la urma, aceasta este cea mai utilizata
                tehnologie pentru realizarea de interfete si este extrem de bine testata. In plus, puteam sa ne folosim
                direct cunostintele legate de frontend, in loc sa calculam si sa implementam noi un sistem pentru
                interfata.</p>
        </section>
        <section id="gameEnd">
            <h3>Sfarsitul jocului</h3>
            <p>
                Cand jucatorul isi pierde toate punctele de vitalitate, jocul afiseaza punctajul jucatorului, locul sau
                in clasament si primii jucatori. De aici ei pot descarca traseul parcurs si top-ul jucatorilor.
            </p>
        </section>
        <section id="formats">
            <h3>Formatele exportate</h3>
            <p>
                Pe parcursul jocului sunt salvate punctele geografice prin care trece jucatorul, iar la final el poate
                descarca un fisier GPX cu traseul parcurs. De asemenea pe pagina de final, utilizatorul poate descarca
                clasamentul jocului in format CSV.
            </p>
        </section>
        <section id="mobile">
            <h3>Versiunea de mobil</h3>
            <p>
                Pentru versiunea de mobil am adaugat o implementare open-source numita JOY.JS pentru un joystick
                html5[1]. Pe ecranele mici, sunt 2 joystick-uri: cel din dreapta este pentru miscarea personajului, iar
                cel din stanga, daca nu este in starea default, trimite un proiectil in directia in care este indreptat.
            </p>
        </section>
        <section id="mapbox">
            <h3>Hartile din Mapbox GL JS</h3>
            <p>
                Unul din api-urile pe care le-am folosit a fost cel de geolocatie. Acesta ne intorcea cele mai apropiate
                obiecte (strazi, cladiri, monumente, etc). Insa problema era ca nu ne intorcea coordonatele conturului
                acestora. Am cautat suplimentar fata de acesta alt serviciu si am realizat la dupa ce pornisem proiectul
                ca nu exista un api pentru delimitarile
                cladirilor/ monumentelor/ formelor de relief, care sa fie accesibil prin cerere http. Pana si google,
                care are o colectie foarte mare de harti si alte api-uri legate de acestea, nu avea un astfel de
                serviciu.
                Nici Openstreetmaps, nici alte domenii. Si pe noi ne-a intrigat acest aspect, dar am descoperit un
                serviciu de la Mapbox care permitea descarcarea de fisiere compresate care contineau astfel de
                informatii.
                Insa in ciuda efortului depus, nu am reusit sa despachetam formatul respective (.pbf/.mvt), la inceput
                folosind gunzip, sau alte librarii, in javascript, in python. Formatul pe care Mapbox il punea la
                dispozitie pare ca se despacheta diferit fata de .pbf-urile normale, apartinand google. Un alt domeniu,
                openstreetmaps, mentiona ca are datele respective, dar printre implementarile oferite de ei pentru
                lucrul cu aceste fisiere, nu am gasit
                nicio implementare viabila. Cand spunem ca nu erau viabile, ne referim la mai multe probleme, in primul
                rand, noi doream initial ceva care sa fie sub forma de api, sau daca trebuia sa despachetam noi
                formatele, sa avem si o librarie care sa faca asta, dar unele implementari erau sdk-uri, librarii cu
                licenta non-open-source, sau scrise in c++ (si nu voiam server in c++).
            </p>
            <p>
                Dar am gasit o solutie pana la urma. Totusi hartile pe care le vedem noi pe site-uri cum fac?, ne-am
                intrebat. Am descoperit ca intr-o implementare pentru harti embedded folosind canvas pentru web, era
                posibil pentru noi sa interogam harta la momentul curent si sa intoarcem coordonatele cladirilor. Dar,
                din pacate, cand am incercat sa luam aceasta librarie sa o punem pe server ca sa incapsulam intr-un api
                propriu functionalitatea, am descoperit ca libraria era incompatibila cu node.js - era doar pentru web.
                Si da, am incercat, in primul rand sa reparam dependintele, dupa sa emulam un browser pe serverul de
                node, insa, dupa multe incercari, am renuntat. In final, pentru a construi harta noastra, ne folosim de
                harta celor de la Mapbox. Libraria este open-source, insa cum despacheteaza exact formatul, nu am reusit
                sa reproducem, am investigat si am trecut din nou prin implementari si prin gunzip si prin librarii, dar
                a trebuit sa alegem ca solutie finala utilizarea acestei librarii pe front-end. Daca am fi reusit, am fi
                putut sa mutam cladirile, interactiunea cu ele pe server, si sa facem jocul si mai performant, si chiar
                ne-am fi dorit acest lucru. Insa aveam doar optiunea de frontend, iar ideea de a transmite coordonatele
                serverului pentru a controla el coliziunea nu ar fi fost un lucru benefic.
            </p>
        </section>
        <section id="multiplayer">
            <h3>Multiplayer</h3>
            <p>Un lucru interesant la un joc retro este sa ai capabilitati multiplayer. In aplicatia noastra jucatorii
                isi pot observa unul celuilalt pozitia, orientarea curenta si pot interactiona prin intermediul
                chat-ului. Totusi, ei nu se vor putea ciocni sau lupta monstri impreuna. Calculele nu se realizeaza la
                nivel de server, ci jocul este client-based, din cauza ca nu puteam muta calculele pe server,
                desi daca reuseam, am fi fost si mai multumiti.
            </p>
            <p>
                La inceperea jocului se realizeaza o conexiune cu serverul prin SocketIO (detalii mai jos). Clientul
                trimite la un interval de timp, la inceput mai mare (1s), coordonatele serverului. Daca jucatorul are in
                jurul sau pe altcineva, acest interval se micsoreaza la o anumita valoare, astfel incat coordonatele sa
                fie transmise mai repede pentru a fi actualizate intre clienti. Acest mod de comunicare reprezinta o
                optimizare pentru a nu folosi intens resursele atunci cand jucatorii nu au pe cineva in proximitatea
                lor.
            </p>
            <p>
                Odata cu coordonatele trimise, jucatorii trimit si punctajul curent, iar serverul realizeaza un
                clasament live al jucatorilor pe care il ofera prin api. Pe UI-ul jocului in coltul din dreapta sus este
                o tabela care se actualizeaza live apeland acest api.
            </p>
            <p>
                La deconectare, serverul intelege ca sesiunea de joc a utilizatorului s-a terminat si inregistreaza in
                baza de date ultimul punctaj obtinut. Clientul va obtine prin apelarea api-ului locul sau in clasament
                dupa inserare si top-ul jucatorilor.
            </p>
        </section>
    </section>
    <section id="app">
        <h2>Implementarea aplicatiei</h2>

        <section id="site">
            <h3>Realizarea paginilor site-ului</h3>
            <p>
                Pe prima pagina este formularul de intrare in joc. La incarcarea paginii, browser-ul va cere permisiunea
                pentru geolocatie. In cazul in care utilizatorul isi da acordul pentru preluarea datelor, se completeaza
                in formularul de inceput de joc coordonatele sale. Altfel el ramane cu anumite coordonate default,
                acestea fiind o anumita zona din Iasi, orasul in care a fost implementat acest proiect. Dupa ce un
                utilizator isi scrie un username dorit,
                este directionat pe pagina jocului. Transmiterea coordonatelor si a numelui de utilizator intre pagini
                este realizata cu LocalStorage pe browser-ele care suporta aceasta, altfel prin intermediul parametrilor
                in adresa url.
            </p>
            <p>
                Paginile au fost analizate cu grija sa permita
            </p>
        </section>
        <section id="server">
            <h3>Pornirea server-ului</h3>
            <p>
                Intrucat incepusem sa invatam javascript cu implementarea jocului si din operatiile de frontend, ne-am
                hotarat sa pastram limbajul si sa apelam la tehnologiile NodeJS. De asemenea aveam la inceput intentia
                sa integram algoritmii pentru coliziune si alte functionalitati ale jocului pe server, pentru
                performanta, insa s-a dovedit ca trebuie sa le pastram pe client.
            </p>
            <p>
                Serverul trebuia atat sa intoarca fisierele pentru pagini, dar trebuia si sa comunice cu clientul prin
                api de tip REST. La inceput faceam un switch pentru a detecta daca era o resursa sau un api si apelam
                functiile potrivite. Un fisier de configurare pe server in format json ne spunea ce fisiere avem, ruta
                pe care puteau fi accesate si tipul lor. Insa dupa am renuntat la acest fisier de configurare pentru
                pagini si recurs la o implementare mai organizata, cea de tip MVC.
            </p>
        </section>
        <section id="mvc">
            <h3>Arhitectura MVC</h3>
            <p>
                Pentru a realiza o arhitectura MVC am creat clasele Router, Controller si Model. Router-ul face legatura
                dintre ruta la care primim request-ul si controller-ul care trebuie sa intoarca raspunsul. Sunt doua
                tipuri de controllere: ApiController si ResourceController. ResourceController se ocupa cu citirea
                fisierelor resursa si trimiterea lor, iar ApiController executa o anumita procedura si intoarce
                rezultatul acesteia. Controller-ele comunica cu clasa Model, responsabila cu accesul la baza de date si
                logica aplicatiei. Pentru fisierele pe care trebuiau aplicate template-uri, am fi putut utiliza o clasa
                View care sa substituie campurile ce aveau continutul '{{ variabila }}' cu valoarea respectiva din
                Model, insa noi am folosit mai mult api-uri ca sa ne umplem continutul, avand nevoie de versiunea live,
                si nu versiunea la incarcare.
            </p>
            <p>Model foloseste o clasa asemanatoare cu PageLoader, ApiLoader, si el cu rol de a incarca asincron
                api-urile si a intoarce in acelasi timp raspunsul. Diferenta este ca in timp ce PageLoader stoca datele
                primite la nivel global, ApiLoader nu poate pune in variabile global rezultatele si le ofera
                callback-urilor un context local in care sa-si puna rezultatul interogarilor si de asemenea rezolva
                request-ul primit doar daca toate callback-urile au reusit, iar in
                caz contrar trimite un cod de eroare.</p>
        </section>
        <section id="socketio">
            <h3>Comunicarea prin SocketIO</h3>
            <p>Websocket-urile permit comunicarea in timp real cu clientii, lucru necesar in momentul in care vrem
                ca jucatorii sa se poata vedea unii pe ceilalti in acelasi timp. Pe aceasta tehnologie se bazeaza
                libraria SocketIO, pe care am integrat-o cu jocul nostru, atat pe partea de server cat si pe partea de
                client. In momentul conectarii se creeaza socket-uri, clientul si serverul ramanand conectati pe tot
                parcursul jocului. Comunicarea incepe cu clientul trimitand o cerere HTTP catre server cu
                continutul"Upgrade: websocket". Daca serverul accepta, comunicarea se realizeaza din acel moment cu
                protocolul WS, care trimite si accepta pachete mai mici, pentru a creste viteza. </p>
            <p>
                Serverul si clientul isi pot trimite unul altuia evenimente si un buffer de date odata cu acel
                eveniment.
            </p>
            <p>Cea mai des implementata aplicatie a websocket-urilor sunt chat-urile, si am vrut sa includem si noi o
                fereastra de chat. Asa putem folosi functionalitatea de broadcast a serverului de websocket-uri, care
                atunci cand primeste un eveniment de la client ca s-a trimis un mesaj, face broadcast pentru toti
                clientii conectati cu datele primite.</p>
        </section>
        <section id="bd">
            <h3>Baza de date</h3>
            <p>Pentru baza de date am folosit MongoDB, fiind o alegere recomandata pentru serverele de NodeJS, si dorind
                sa experimentam cu o baza de date NoSQL. De asemenea serviciile MongoDB ne permiteau sa folosim o baza
                de date in cloud gratis, si asta ne-a permis sa nu mai ingreunam proiectul cu o configuratie locala a
                bazei de date, noi lucrand fiecare separat.</p>
        </section>
        <section id="api">
            <h3>Api-urile create</h3>
            <p>Aplicatia foloseste activ informatiile gasite pe server si le preia comunicand REST cu acesta.</p>
            <section id="livescores">
                <h4>Livescores</h4>
                <p>Acest api primeste ca parametru in url o constanta "count", si intoarce primele "count" inregistrari
                    de utilizatori din lista de jucatori activi, sortati dupa punctaj. Inregistrarile sunt sub forma
                    unui json cu un vector de obiecte.</p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
[{"username": "player1", "currentPoints":"100"}, {"username":"player2", "currentPoints": "11"}...]
                    </pre>
                </figure>
            </section>
            <section id="leaderboards">
                <h4>LeaderBoards</h4>
                <p>Acest api returneaza primii "count" jucatori dupa punctaj care au terminat jocul, si care au un
                    punctaj mai mare decat parametrul optional "myScore". Pe langa vectorul de obiecte, daca am vrea sa
                    stim cati jucatori sunt cu punctaj mai mare decat myScore, dar totusi sa intoarcem doar "count"
                    elemente, api-ul intoarce numarul de astfel de jucatori sub campul "myPlace".
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"players":[{"username": "player1", "currentPoints":"100"}, {"username":"player2", "currentPoints": "11"}...], "myPlace":"1"}
                    </pre>
                </figure>
            </section>
            <section id="weathertime">
                <h4>Weather and Time</h4>
                <p>Api-ul ofera informatii despre vreme si timp la coordonatele trimise ca parametri: ["lat", "lng"]. In obiectul "weather" sunt mai multe informatii, dar jocul foloseste in special campul "main", care poate fi ["Rain", "Snow", etc.] si campul "time" care precizeaza ora in minute.
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"weather": {...},"time": 900}
                    </pre>
                </figure>
            </section>
            <section id="nearby">
                <h4>NeabyFeatures</h4>
                <p>Acest api intoarce o descriere a locației curente a utilizatorului (trimise ca ["lat", "lng"]),
                    clientul putând afla numele
                    celei mai apropiate străzi, clădiri sau monument din imediata vecinătate a jucatorului. Mesajele
                    sunt personalizate cu formulari misterioase cu rolul de a pastra o nuanta de poveste intr-un context
                    realistic.</p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"name": "Strada Palas","topText": "","bottomText": " is in your sight"}
                    </pre>
                </figure>
            </section>
            <section id="aconfig">
                <h4>Config</h4>
                <p>Nu in ultimul rand este api-ul de config, care intoarce clientului parametri pentru joc, asa cum au
                    fost stabiliti de administator.</p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"maxNrOfMonsters":10,"isNight":false,"rain":false,"snow":false,"playerMaxHealth":100,"moneyPowerUpValue":50,"displacement":0.000002,"speedDisplacement":1.45,"scale":2.5,"leaderBoardCount":7}
                    </pre>
                </figure>
            </section>
        </section>
        <section id="config">
            <h3>Modulul de configurare</h3>
            <p>
                Ca si administratori ai serverului, putem ajusta anumiti parametri ai jocului in functie de feedback-ul
                pe care il primim de la jucatori sau daca observam un mod prin care putem imbunatati experienta jocului.
                Aceasta o facem printr-un fisier de configurare, care contine constante pentru joc: cati monstri sunt
                creati la inceput, numarul de puncte de viata ale jucatorului, se poate seta o vreme globala pentru joc,
                la ce scala este desenata harta etc.
            </p>
        </section>
    </section>
    <section id="development">
        <h2>Procesul de dezvoltare</h2>

        <section id="repo">
            <h3>Github</h3>
            <p>
                Pentru managementul codului sursa am folosit Github. Aceasta platforma a venit cu o multime de avantaje,
                si am fost foarte multumiti de ea. Pe langa posibilitatea de a vedea in browser codul sursa si a
                modificarilor facute pe parcursul proiectului, Github ne-a permis sa facem si un Project Board. Pe acest
                board noi puteam stabili si crea task-uri, ca sa stim care este partea din proiect de care trebuie sa se
                ocupe fiecare. De asemenea ne arata si statistici, cat de mult am scris, cat de des, si cat mai avem
                pana terminam toate cerintele.
            </p>
        </section>
        <section id="static">
            <h3>Analiza statica</h3>
            <p>DeepScan este un analizator static pentru javascript, si ne-a permis sa observam erori sau sa ne
                imbunatatim codul. De exemplu acesta ne spunea cand o variabila este declarata dar nu este folosita
                nicaieri, cand o anumita conditie ajungea sa fie indeplinita mereu, etc. DeepScan ofera analiza gratis
                la conectarea cu Github prin programul Github Student Developer Pack.
            </p>
        </section>
        <section id="deployment">
            <h3>Lansare continua (Continuous Deployment)</h3>
            <p>
                Probabil cea mai folositoare metoda de testare pentru proiect a fost ca am putut avea versiunea live a
                proiectului inca de la inceput. Folosind oferta gratis de la DigitalOcean in parteneriat cu Github, am
                putut configura un vm pe care sa pornim serverul nostru. La scurt timp, am adaugat o optiune in Github
                ca la fiecare push pe branch-ul master sa actualizam serverul. Am facut asta utilizand o actiune
                open-source de la Github prin care putem sa inseram o cheie ssh care sa se conecteze la masina virtuala
                si sa faca un git pull, dupa care sa reporneasca serverul. Initial eram reticenti la folosirea unei chei
                ssh pe un repo public, gandindu-ne ca oricine ar putea sa ia cheia si sa se conecteze la server, insa
                Github a implementat foarte inteligent solutia pentru astfel de probleme: pe Github exista o sectiune
                numita "Secrets". Aici se pot pune date de tip nume-valoare, date care pot fi folosite in actiuni, iar
                modul in care acestea ofera securitate sistemului este ca odata inserata o valoare, ea nu poate fi
                accesata de niciun membru, ci e posibil sa fie utilizata doar in actiuni. A fost prima data cand am
                implementat o astfel de actiune, dar cei de la Github au facut ca tot procesul sa fie foarte usor si la
                indemana de realizat, iar in final, am reusit. Serverul se actualiza la fiecare schimbare care o puneam
                pe repo.
            </p>
        </section>
        <section id="logging">
            <h3>Inregistrarea erorilor in log</h3>
            <p>
                Atunci cand serverul nostru este la distanta, se poate intampla ca ceva sa mearga rau, iar noi sa nu
                realizam sau sa putem vedea output-ul pentru ca nu avem acces imediat la acea masina. Pentru asta am
                implementat ca la fiecare pornire,
                serverul sa faca un fisier de log intr-un folder, si sa il numeasca utilizand data si ora la care a fost
                pornit. Astfel, daca vom avea nevoie sa vedem din ce motiv a picat serverul sau daca s-a intamplat ceva
                neprevazut, putem inspecta log-urile.
            </p>
            <p>
                Mai trebuie mentionat ca fisierul de log-uri a trebuit sa-l trecem ca exceptie in .gitignore, pentru ca
                sa nu existe conflicte de vreun fel cand serverul executa pull pe repo (ar fi putut vedea un conflict
                intre doua fisiere de log numite la fel).
            </p>
        </section>
    </section>
    <section id="conclusion">
        <h2>Concluzii</h2>
        <p></p>
    </section>

























    </section>


</body>

</html>